\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage[margin=0.7in]{geometry}
\usepackage[document]{ragged2e}
\usepackage{multicol}

\begin{document}

    \begin{center}
    \end{center}
    
    \addvspace{20mm}
        
    \begin{center}
        \huge Novel use of a Functional HDL to Simplify Development of an RNG Brute-Force Algorithm
    \end{center}
    
    \begin{center}
    \end{center}
       
    \begin{center}
        \large Andreas Stocker
    \end{center}
    
    \begin{center}
        \small \emph {University of Nicosia}
    \end{center}

    \addvspace{15mm}

    \begin{multicols}{2}

    \section*{Abstract}

    In this paper we go over the implementation details of an algorithm that brute forces
    the state of a random number generator (RNG). Recovering the internal state of an RNG can allow
    future outputs to be predicted, possibly compromising the security of a system.
    We do so using a hardware description language whose syntax
    resembles that of the Haskell language.
    The purpose of this paper is to assess the practicality of using this functional-style approach in
    designing calculation-heavy algorithms for FPGAs.
    First, we go over the basics of using this high-level hardware description named "Clash".
    We do this in a way that even programmers of more mainstream languages like Java should be able to follow.
    Finally, we go over the difficulties that were overcome as well as any special techniques involved in
    the implementation of the brute force algorithm.

    TODO - add results/conclusions after project is done

    \section{Introduction}

    Today's CPUs make use of the Von Neumann architecture. The Von Neumann architecture dictates the use
    of seperate CPU and memory modules. Furthermore, it dictates that a programs instructions be stored
    in memory.

    This works well for many of today's workloads. This current system has the benefits of decades of optimization
    and feature development.

    However, certain types of computations are bottlenecked by this approach. This is especially true for
    highly parallel calculations.

    GPUs address this need for parallelism but they are still limited by a design that prioritizes
    certain types of calculations.

    Sometimes programmers require a greater degree of control over hardware. Arguably the greatest degree
    of control developers can have is by developing their own ASICs. Modern CPUs and GPUs most
    other silicon chips are themselves ASICs. These ASICs are incredibly expensive to produce however,
    with prices often ranging from the millions into the billions.

    Therefore ASICs are well out of reach for most programmers to use for their personal projects, or even for
    medium sized companies.

    This is where FPGAs enter the picture. Less powerful FPGAs are cheap and widely available. FPGAs themselves
    are often used to prototype ASICs. However they can also be used to implement algorithms where precise control
    over circuitry is needed.

    FPGAs allow circuits to be dynamically programmed using lookup tables (LUTs). The more LUTs an FPGA
    has the more complex the circuits it can be configured for. These circuits can be configured for
    extreme parallelism. This is because unlike conventional CPUs, FGPAs are not limited by something like a core count,
    they simply have wires on a circuit.

    Despite having these strong advantages, one of the greatest disadvantages FPGAs suffer from is complexity of development.
    Since developers are working on a far lower level than even assembly language, the complexity
    of programming FPGAs is often far higher. Programmers familiar with high level languages
    like Java will not be able to use a lot of the knowledge they aquired and will need to learn electrical engineering
    concepts to create advanced FPGA projects.

    This is were the purpose of this paper is relevant. The paper will explore whether using the
    functional hardware description language (HDL) "Clash" can make FPGA development more accessible by providing
    the right abstractions.    
    
    \section{Clash Basics}

    The syntax of Clash is very much inspired by the purely functional Haskell programming language.
    The Clash project has two main components. The first major component is the compiler.
    The Clash compiler takes the Haskell-like syntax and compiles it down
    into one of the more popular hardware description languages (HDLs).
    These hardware description languages include VHDL, Verilog and SystemVerilog.
    The second major component of the Clash language are a set of libraries that
    are used for circuit design.

    Not only does Clash reuse the Haskell syntax, it actually reuses parts of the
    Glasgow Haskel Compiler.

    Now concerning the maturity of the Clash project, it has the benefit of having
    a number of years to evolve. At this time of writing it has been actively
    developed for over ten years. [TODO add link to clash docs]

    For developers to quickly get started with Clash, there are two main things they
    should be familiar with. First is basic knowledge of hardware description languages
    such as Verilog. Second, is a decent understanding of functional programming
    languages, especially Haskell.

    Before diving into the details of using Clash there is a major potential issue
    that presents itself right from the start. Programmers only familiar with
    conventional high level languages like Java and C++ may not be aware of this,
    but those with a decent amount of experience with HDLs like Verilog probably will.

    That feature is formal Verification. Formal Verification is indispensable for
    virtually any serious hardware design project. When looking back on their workflow,
    seasoned experts that use HDL often lament that they needlessly spent
    large amounts of time fighting bugs that formal verification could have dealt with in
    a far more efficient manner. [TODO add link to youtube talk by zipcpu creator]

    Clash does have a built in testing system so perhaps if the testing framework is
    powerful and expressive enough it may be able to compensate somewhat
    for the lack of support for formal verification.

    Finally, Clash does not appear do directly support timing analysis. Timing analysis
    is again something that only those with HDL experience will likely know about. It is
    however a critical aspect of FPGA and circuit design in general. Timing analysis is a
    very complex procedure that calculates how long a signal takes to propagate
    through a circuit. If a signal is not given enough time to propagate, inconsistencies
    will arise in the circuit. The main way to mitigate this is to reduce the clock speed
    of the circuit.

    Despite this lack of direct support for timing analysis in the Clash project itself,
    it is likely possible to perform timing analysis with standard HDL tools since
    Clash compiles to lower level HDLs.

    This could present some serious challenges since the compiled output will
    likely not be human-readable. This is something that will be explored in the paper.
    
    \section{Related Work}

    Todo - add this

    THIS COMES NEAR THE END

    
    \end{multicols}

    \break
    \section*{References}

    \begin{enumerate}

    \item Chandrasekaran, Shrutisagar, and Abbes Amira. "High performance FPGA implementation of the Mersenne Twister." 4th IEEE International Symposium on Electronic Design, Test and Applications (delta 2008). IEEE, 2008.

    \end{enumerate}
    
\end{document}
